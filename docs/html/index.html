<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>main: STM32 Dynamic Linking</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">main
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">STM32 Dynamic Linking </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br />
 </p>
<p>Minimal example of dynamic apps. <br />
 <a href="https://rgujju.github.io/STM32_Dynamic_Apps/html/index.html"><b>Doxygen docs Â»</b></a> <br />
 </p>
<h2>About The Project</h2>
<p>This is a minimal example of having dynamic apps with syscall functionality. It is divided into 2 parts, the kernel and the app. The kernel is responsible for loading the app and handling syscall functionality. The syscall functionality is implemented using jumptables. The app can then call APIs present in the kernel through this jump table.</p>
<h4>Kernel</h4>
<p>At the moment the kernel is nothing but the FreeRTOS and 2 functions, the <code>SetLed</code> and <code>LoadApp</code>. The syscall functionality is implemented in the <b>modules/sys_module</b> while the app loading is implemented in the <b>modules/app_loader</b>.</p>
<p>The jumptable struct is <code><a class="el" href="structsys__struct.html" title="This struct contains APIs for calling system functions It is basically a jump table. Depending on weather the KERNEL is built or the libs for the app, different sys_struct definitions are compiled. For Kernel: The complete struct with each member is compiled For userlib for the app: Only a &#39;const sys_struct* sys&#39; pointer is defined. The address of this pointer is made to point to the actual sys_struct in the kernel at load time in the LoadApp API. ">sys_struct</a> sys</code>. It should contain all the APIs (currently only the <code>SetLed</code>) that the app can invoke in the kernel.</p>
<p>The kernel contains the actual code of <code>SetLed</code>, This code does not get compiled into the app again. So this API can be changed without needing to rebuild the app.</p>
<h4>App</h4>
<p>The app is compiled as a Position independent Code. The following flags are used:<code>-fpic -msingle-pic-base -mpic-register=r9 -mno-pic-data-is-text-relative -mlong-calls</code> This creates an executable which can be run from any memory location given that the GOT address is in the register <b>R9</b> gcc generates the executable in elf which contains a lot of information and is quite large for a mcu. So this elf file is converted into <a href="https://github.com/rgujju/STM32_Dynamic_Apps/tree/master/elf2tinf">TINF</a>, which can be easily loaded onto a mcu.</p>
<p>The app invokes syscalls using the pointer <code><a class="el" href="structsys__struct.html" title="This struct contains APIs for calling system functions It is basically a jump table. Depending on weather the KERNEL is built or the libs for the app, different sys_struct definitions are compiled. For Kernel: The complete struct with each member is compiled For userlib for the app: Only a &#39;const sys_struct* sys&#39; pointer is defined. The address of this pointer is made to point to the actual sys_struct in the kernel at load time in the LoadApp API. ">sys_struct</a> sys</code>. The actual address of the <code><a class="el" href="structsys__struct.html" title="This struct contains APIs for calling system functions It is basically a jump table. Depending on weather the KERNEL is built or the libs for the app, different sys_struct definitions are compiled. For Kernel: The complete struct with each member is compiled For userlib for the app: Only a &#39;const sys_struct* sys&#39; pointer is defined. The address of this pointer is made to point to the actual sys_struct in the kernel at load time in the LoadApp API. ">sys_struct</a> sys</code> is added when the app is loaded. When the app invokes a syscall as follows <code>sys-&gt;SetLed(led_num, led_status);</code> the execution flow jumps into the actual location of the <code>SetLed</code> function which was defined in the kernel.</p>
<p>The current example app in <b>apps/blinky</b> turns on the green LED while the kernel turns on the red LED on the STM32F429 DISC1 board.</p>
<p>To learn more about GOT and PIC refer the <a href="#Acknowledgements">Acknowledgements</a>, they do a much better job of explaining the concepts.</p>
<h4>Why did I do this?</h4>
<p>Mainly to learn about the GOT, PIC, memory layout of mcu, and a lot more. Gained a lot of knowledge from this project.</p>
<h2>Usage</h2>
<p>This example is for the STM32F429 DISC1 board. But should be <a href="#Porting">portable</a> to any other mcu. </p><h4>1 Build userlib.a. This is a static library aka archive. The app will be linked to this archive.</h4>
<p><code>mkdir -p build/userlib</code> <code>cd build/userlib</code> <code>cmake ../.. -DTARGET_GROUP=userlib -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=../../cross.cmake</code> <code>make</code> A folder called <b>lib</b> will be created. This folder will contain everything required to build the app. It contains the header files and the userlib.a archive. Copy this folder to the apps folder. <code>cp -R lib ../../apps/</code></p>
<h4>2 Build app. A example app called blinky is provided.</h4>
<p>This app turn on LED1. There is some extra code in the example to purposely populate the data and bss sections And also to verify if the GOT is copied properly. ie global variable access. <code>cd apps</code> <code>mkdir build/</code> <code>cd build</code> <code>cmake .. -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=../../cross.cmake</code> <code>make</code> This should have created <b>blinky.elf</b> file. This file now needs to be converted into TINF.</p>
<h4>3 Create TINF of the app</h4>
<p><code>python3 ../../elf2tinf/elf2tinf.py --major 1 --minor 0 blinky.elf blinky</code> This should generate 2 files, the <b>blinky.tinf</b> and <b>blinky_tinf.h</b> <b>blink.tinf</b> is in a binary format which can be loaded over uart, ble, usb, etc. <b>blinky_tinf.h</b> is the same binary data in the form of a header file, so I can test it easily, without implementing the actual transfer of the binary to the mcu. More details about this tool is in the README.md in folder elf2tinf</p>
<h4>4 Build the kernel</h4>
<p><code>mkdir -p build/debug</code> <code>cd build/debug</code> Build the kernel, this is the code that will actually load the app and run it <code>cmake ../.. -DTARGET_GROUP=kernel -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=../../cross.cmake</code> <code>make</code> This will generate the <b>main.elf</b> file which needs to be loaded onto the board.</p>
<h4>5 Load main.elf to hardware</h4>
<p>This can vary depending on your method. If you use gdb then simply, with something like openocd already running in the background then simply <code>make flash</code></p>
<h2>Documentation</h2>
<p>User documentation is in header files To go deeper see the source files Online docs: <a href="https://rgujju.github.io/STM32_Dynamic_Apps/html/index.html">https://rgujju.github.io/STM32_Dynamic_Apps/html/index.html</a></p>
<h2>Porting</h2>
<ul>
<li>This project uses the STM32F429 mcu but should be portable to any mcu.</li>
<li>Replace <b>components/STM32F4xx_HAL_Driver</b> and <b><a class="el" href="stm32f4xx__hal__conf_8h.html" title="HAL configuration template file. This file should be copied to the application folder and renamed to ...">include/stm32f4xx_hal_conf.h</a></b> with the HAL of your mcu.</li>
<li>Replace <b>include/STM32F4xx</b> with the vendor files for your mcu. These files are basically the system, startup and header files of your mcu.</li>
<li>The above 2 folders are provided by the vendor. In case of STM32, it is possible to use STM32CubeMX to generate them.</li>
<li>Change <em>MCU Setup</em>, <em>HAL Setup</em> to match your mcu in the <b>CMakeLists.txt</b> file.</li>
<li>Linker script <b>linker.ld</b> needs to be changed according to your mcu memory.</li>
</ul>
<h2>Acknowledgements</h2>
<p>I learnt these things from the following resources:</p><ul>
<li><a href="https://github.com/bogdanm/udynlink">https://github.com/bogdanm/udynlink</a></li>
<li><a href="https://github.com/tock/tock">https://github.com/tock/tock</a></li>
<li><a href="https://github.com/pebble-dev/RebbleOS/blob/master/rcore/appmanager.c">https://github.com/pebble-dev/RebbleOS/blob/master/rcore/appmanager.c</a></li>
<li><a href="https://www.airs.com/blog/archives/38">https://www.airs.com/blog/archives/38</a><ul>
<li>40 part explaination about linkers</li>
</ul>
</li>
<li><a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html">https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html</a><ul>
<li>Explains PLT and GOT</li>
</ul>
</li>
<li><a href="https://stackoverflow.com/questions/3322911/what-do-linkers-do/33690144#33690144">https://stackoverflow.com/questions/3322911/what-do-linkers-do/33690144#33690144</a><ul>
<li>Explains relocation with a proper worked out example</li>
</ul>
</li>
<li><a href="https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld/51308031#51308031">https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld/51308031#51308031</a><ul>
<li>Explains PIE relocation with a proper worked out example</li>
</ul>
</li>
<li><a href="https://stac47.github.io/c/relocation/elf/tutorial/2018/03/01/understanding-relocation-elf.html">https://stac47.github.io/c/relocation/elf/tutorial/2018/03/01/understanding-relocation-elf.html</a><ul>
<li>worked out example of relocation in dynamic and static linking</li>
</ul>
</li>
<li>Dynamic linking<ul>
<li>load time relocation<ul>
<li><a href="https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries">https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries</a></li>
<li><a href="https://www.youtube.com/watch?v=wYmhUbhkbhQ">https://www.youtube.com/watch?v=wYmhUbhkbhQ</a> -Demonstrates load time relocation</li>
<li>PIC - Position Independent code<ul>
<li><a href="https://www.youtube.com/watch?v=baNlnNt5OYg">https://www.youtube.com/watch?v=baNlnNt5OYg</a></li>
<li><a href="https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-librariesss">https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-librariesss</a></li>
<li><a href="https://www.youtube.com/watch?v=fnbBKinIumw&list=PLyqSpQzTE6M-q0Xgn0icEHvUS7WQxvenv&index=14">https://www.youtube.com/watch?v=fnbBKinIumw&amp;list=PLyqSpQzTE6M-q0Xgn0icEHvUS7WQxvenv&amp;index=14</a><ul>
<li>Explains ASLR and load time relocation and PIC</li>
</ul>
</li>
</ul>
</li>
<li>For Cortex-M<ul>
<li><a href="https://stackoverflow.com/questions/5619178/how-to-write-dynamic-loader-for-bare-metal-arm-application">https://stackoverflow.com/questions/5619178/how-to-write-dynamic-loader-for-bare-metal-arm-application</a><ul>
<li>Explains how to do jump tables (jumptables) using C struct</li>
</ul>
</li>
<li><a href="https://stackoverflow.com/questions/50655162/stm32-position-independent-binaries">https://stackoverflow.com/questions/50655162/stm32-position-independent-binaries</a><ul>
<li>Position independent code</li>
</ul>
</li>
<li><a href="https://github.com/embedded2014/elf-loader">https://github.com/embedded2014/elf-loader</a></li>
<li><a href="https://github.com/martinribelotta/elfloader">https://github.com/martinribelotta/elfloader</a><ul>
<li>ELF Loader</li>
</ul>
</li>
<li><a href="http://www.chibios.com/forum/viewtopic.php?f=3&t=1229">http://www.chibios.com/forum/viewtopic.php?f=3&amp;t=1229</a><ul>
<li>partial linking and comparison of different dynamic loading options</li>
</ul>
</li>
<li><a href="https://stackoverflow.com/questions/44632383/dynamically-load-code-on-embedded-target">https://stackoverflow.com/questions/44632383/dynamically-load-code-on-embedded-target</a><ul>
<li>Shows partial linking</li>
<li>In the ld documentation check out &ndash;relocatable and &ndash;just-symbols</li>
</ul>
</li>
<li><a href="https://static.docs.arm.com/ihi0044/f/IHI0044F_aaelf.pdf">https://static.docs.arm.com/ihi0044/f/IHI0044F_aaelf.pdf</a><ul>
<li>ARM ELF Format </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
